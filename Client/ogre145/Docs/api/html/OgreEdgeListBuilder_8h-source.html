<html>
<head>
<title>OGRE: OgreEdgeListBuilder.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>OgreEdgeListBuilder.h</h1><a href="OgreEdgeListBuilder_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">    (Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.ogre3d.org/</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2006 Torus Knot Software Ltd</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU Lesser General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU Lesser General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/lesser.txt.</span>
00023 <span class="comment"></span>
00024 <span class="comment">You may alternatively use this source under the terms of a specific version of</span>
00025 <span class="comment">the OGRE Unrestricted License provided you have obtained such a license from</span>
00026 <span class="comment">Torus Knot Software Ltd.</span>
00027 <span class="comment">-----------------------------------------------------------------------------</span>
00028 <span class="comment">*/</span>
00029 <span class="preprocessor">#ifndef __EdgeListBuilder_H__</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define __EdgeListBuilder_H__</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#include "<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="OgreVector4_8h.html">OgreVector4.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="OgreHardwareVertexBuffer_8h.html">OgreHardwareVertexBuffer.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="OgreRenderOperation_8h.html">OgreRenderOperation.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="OgreAlignedAllocator_8h.html">OgreAlignedAllocator.h</a>"</span>
00037 
00038 <span class="keyword">namespace </span>Ogre {
00039 
00040 
<a name="l00047"></a><a class="code" href="classOgre_1_1EdgeData.html">00047</a>     <span class="keyword">class </span><a class="code" href="OgrePlatform_8h.html#a16">_OgreExport</a> EdgeData
00048     {
00049     <span class="keyword">public</span>:
<a name="l00051"></a><a class="code" href="structOgre_1_1EdgeData_1_1Triangle.html">00051</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeData_1_1Triangle.html">Triangle</a> {
<a name="l00054"></a><a class="code" href="structOgre_1_1EdgeData_1_1Triangle.html#Ogre_1_1EdgeData_1_1Triangleo0">00054</a>             size_t indexSet; 
<a name="l00056"></a><a class="code" href="structOgre_1_1EdgeData_1_1Triangle.html#Ogre_1_1EdgeData_1_1Triangleo1">00056</a>             size_t vertexSet;
<a name="l00057"></a><a class="code" href="structOgre_1_1EdgeData_1_1Triangle.html#Ogre_1_1EdgeData_1_1Triangleo2">00057</a>             size_t vertIndex[3];
<a name="l00058"></a><a class="code" href="structOgre_1_1EdgeData_1_1Triangle.html#Ogre_1_1EdgeData_1_1Triangleo3">00058</a>             size_t sharedVertIndex[3]; 
00059                                         <span class="comment">// duplicates eliminated (this buffer is not exposed)</span>
00060         };
<a name="l00062"></a><a class="code" href="structOgre_1_1EdgeData_1_1Edge.html">00062</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeData_1_1Edge.html">Edge</a> {
<a name="l00066"></a><a class="code" href="structOgre_1_1EdgeData_1_1Edge.html#Ogre_1_1EdgeData_1_1Edgeo0">00066</a>             size_t triIndex[2];
<a name="l00069"></a><a class="code" href="structOgre_1_1EdgeData_1_1Edge.html#Ogre_1_1EdgeData_1_1Edgeo1">00069</a>             size_t vertIndex[2];
<a name="l00071"></a><a class="code" href="structOgre_1_1EdgeData_1_1Edge.html#Ogre_1_1EdgeData_1_1Edgeo2">00071</a>             size_t sharedVertIndex[2];
<a name="l00073"></a><a class="code" href="structOgre_1_1EdgeData_1_1Edge.html#Ogre_1_1EdgeData_1_1Edgeo3">00073</a>             <span class="keywordtype">bool</span> degenerate;
00074         };
00075 
00076         <span class="comment">// Array of 4D vector of triangle face normal, which is unit vector othogonal</span>
00077         <span class="comment">// to the triangles, plus distance from origin.</span>
00078         <span class="comment">// Use aligned allocator here because we are intented to use in SIMD optimised routines .</span>
<a name="l00079"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDataw0">00079</a>         <span class="keyword">typedef</span> std::vector&lt;Vector4, AlignedAllocator&lt;Vector4&gt; &gt; TriangleFaceNormalList;
00080 
00081         <span class="comment">// Working vector used when calculating the silhouette.</span>
00082         <span class="comment">// Use std::vector&lt;char&gt; instead of std::vector&lt;bool&gt; which might implemented</span>
00083         <span class="comment">// similar bit-fields causing loss performance.</span>
<a name="l00084"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDataw1">00084</a>         <span class="keyword">typedef</span> std::vector&lt;char&gt; TriangleLightFacingList;
00085 
<a name="l00086"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDataw2">00086</a>         <span class="keyword">typedef</span> std::vector&lt;Triangle&gt; TriangleList;
<a name="l00087"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDataw3">00087</a>         <span class="keyword">typedef</span> std::vector&lt;Edge&gt; EdgeList;
00088 
<a name="l00090"></a><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html">00090</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html">EdgeGroup</a>
00091         {
<a name="l00093"></a><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html#Ogre_1_1EdgeData_1_1EdgeGroupo0">00093</a>             size_t vertexSet;
<a name="l00095"></a><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html#Ogre_1_1EdgeData_1_1EdgeGroupo1">00095</a>             <span class="keyword">const</span> <a class="code" href="classOgre_1_1VertexData.html">VertexData</a>* vertexData;
<a name="l00100"></a><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html#Ogre_1_1EdgeData_1_1EdgeGroupo2">00100</a>             size_t triStart;
<a name="l00102"></a><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html#Ogre_1_1EdgeData_1_1EdgeGroupo3">00102</a>             size_t triCount;
<a name="l00104"></a><a class="code" href="structOgre_1_1EdgeData_1_1EdgeGroup.html#Ogre_1_1EdgeData_1_1EdgeGroupo4">00104</a>             EdgeList edges;
00105 
00106         };
00107 
<a name="l00108"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDataw4">00108</a>         <span class="keyword">typedef</span> std::vector&lt;EdgeGroup&gt; EdgeGroupList;
00109 
<a name="l00113"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDatao0">00113</a>         TriangleList triangles;
<a name="l00115"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDatao1">00115</a>         TriangleFaceNormalList triangleFaceNormals;
<a name="l00117"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDatao2">00117</a>         TriangleLightFacingList triangleLightFacings;
<a name="l00119"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDatao3">00119</a>         EdgeGroupList edgeGroups;
<a name="l00121"></a><a class="code" href="classOgre_1_1EdgeData.html#Ogre_1_1EdgeDatao4">00121</a>         <span class="keywordtype">bool</span> isClosed;
00122 
00123 
00133         <span class="keywordtype">void</span> updateTriangleLightFacing(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector4.html">Vector4</a>&amp; lightPos);
00139         <span class="keywordtype">void</span> updateFaceNormals(size_t vertexSet, <span class="keyword">const</span> <a class="code" href="classOgre_1_1HardwareVertexBufferSharedPtr.html">HardwareVertexBufferSharedPtr</a>&amp; positionBuffer);
00140 
00141 
00142 
00143         <span class="comment">// Debugging method</span>
00144         <span class="keywordtype">void</span> log(<a class="code" href="classOgre_1_1Log.html">Log</a>* log);
00145         
00146     };
00147 
<a name="l00157"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html">00157</a>     <span class="keyword">class </span><a class="code" href="OgrePlatform_8h.html#a16">_OgreExport</a> EdgeListBuilder 
00158     {
00159     <span class="keyword">public</span>:
00160 
00161         EdgeListBuilder();
00162         <span class="keyword">virtual</span> ~EdgeListBuilder();
00168         <span class="keywordtype">void</span> addVertexData(<span class="keyword">const</span> <a class="code" href="classOgre_1_1VertexData.html">VertexData</a>* vertexData);
00179         <span class="keywordtype">void</span> addIndexData(<span class="keyword">const</span> <a class="code" href="classOgre_1_1IndexData.html">IndexData</a>* indexData, size_t vertexSet = 0, 
00180             RenderOperation::OperationType opType = RenderOperation::OT_TRIANGLE_LIST);
00181 
00186         EdgeData* build(<span class="keywordtype">void</span>);
00187 
00189         <span class="keywordtype">void</span> log(<a class="code" href="classOgre_1_1Log.html">Log</a>* l);
00190     <span class="keyword">protected</span>:
00191 
<a name="l00197"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html">00197</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html">CommonVertex</a> {
<a name="l00198"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html#Ogre_1_1EdgeListBuilder_1_1CommonVertexo0">00198</a>             <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>  position;  <span class="comment">// location of point in euclidean space</span>
<a name="l00199"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html#Ogre_1_1EdgeListBuilder_1_1CommonVertexo1">00199</a>             size_t index;       <span class="comment">// place of vertex in common vertex list</span>
<a name="l00200"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html#Ogre_1_1EdgeListBuilder_1_1CommonVertexo2">00200</a>             size_t vertexSet;   <span class="comment">// The vertex set this came from</span>
<a name="l00201"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html#Ogre_1_1EdgeListBuilder_1_1CommonVertexo3">00201</a>             size_t indexSet;    <span class="comment">// The index set this was referenced (first) from</span>
<a name="l00202"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html#Ogre_1_1EdgeListBuilder_1_1CommonVertexo4">00202</a>             size_t originalIndex; <span class="comment">// place of vertex in original vertex set</span>
00203         };
<a name="l00205"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html">00205</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html">Geometry</a> {
<a name="l00206"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html#Ogre_1_1EdgeListBuilder_1_1Geometryo0">00206</a>             size_t vertexSet;           <span class="comment">// The vertex data set this geometry data refers to</span>
<a name="l00207"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html#Ogre_1_1EdgeListBuilder_1_1Geometryo1">00207</a>             size_t indexSet;            <span class="comment">// The index data set this geometry data refers to</span>
<a name="l00208"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html#Ogre_1_1EdgeListBuilder_1_1Geometryo2">00208</a>             <span class="keyword">const</span> <a class="code" href="classOgre_1_1IndexData.html">IndexData</a>* indexData; <span class="comment">// The index information which describes the triangles.</span>
<a name="l00209"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html#Ogre_1_1EdgeListBuilder_1_1Geometryo3">00209</a>             RenderOperation::OperationType opType;  <span class="comment">// The operation type used to render this geometry</span>
00210         };
<a name="l00212"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1geometryLess.html">00212</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeListBuilder_1_1geometryLess.html">geometryLess</a> {
<a name="l00213"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1geometryLess.html#Ogre_1_1EdgeListBuilder_1_1geometryLessa0">00213</a>             <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html">Geometry</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html">Geometry</a>&amp; b)<span class="keyword"> const</span>
00214 <span class="keyword">            </span>{
00215                 <span class="keywordflow">if</span> (a.vertexSet &lt; b.vertexSet) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00216                 <span class="keywordflow">if</span> (a.vertexSet &gt; b.vertexSet) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00217                 <span class="keywordflow">return</span> a.indexSet &lt; b.indexSet;
00218             }
00219         };
<a name="l00221"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1vectorLess.html">00221</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1EdgeListBuilder_1_1vectorLess.html">vectorLess</a> {
<a name="l00222"></a><a class="code" href="structOgre_1_1EdgeListBuilder_1_1vectorLess.html#Ogre_1_1EdgeListBuilder_1_1vectorLessa0">00222</a>             <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; a, <span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; b)<span class="keyword"> const</span>
00223 <span class="keyword">            </span>{
00224                 <span class="keywordflow">if</span> (a.x &lt; b.x) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00225                 <span class="keywordflow">if</span> (a.x &gt; b.x) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00226                 <span class="keywordflow">if</span> (a.y &lt; b.y) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00227                 <span class="keywordflow">if</span> (a.y &gt; b.y) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00228                 <span class="keywordflow">return</span> a.z &lt; b.z;
00229             }
00230         };
00231 
<a name="l00232"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderx0">00232</a>         <span class="keyword">typedef</span> std::vector&lt;const VertexData*&gt; VertexDataList;
<a name="l00233"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderx1">00233</a>         <span class="keyword">typedef</span> std::vector&lt;Geometry&gt; GeometryList;
<a name="l00234"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderx2">00234</a>         <span class="keyword">typedef</span> std::vector&lt;CommonVertex&gt; CommonVertexList;
00235 
<a name="l00236"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderp0">00236</a>         GeometryList mGeometryList;
<a name="l00237"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderp1">00237</a>         VertexDataList mVertexDataList;
<a name="l00238"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderp2">00238</a>         CommonVertexList mVertices;
<a name="l00239"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderp3">00239</a>         EdgeData* mEdgeData;
<a name="l00241"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderx3">00241</a>         <span class="keyword">typedef</span> std::map&lt;Vector3, size_t, vectorLess&gt; CommonVertexMap;
<a name="l00242"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderp4">00242</a>         CommonVertexMap mCommonVertexMap;
<a name="l00246"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderx4">00246</a>         <span class="keyword">typedef</span> std::multimap&lt; std::pair&lt;size_t, size_t&gt;, std::pair&lt;size_t, size_t&gt; &gt; EdgeMap;
<a name="l00247"></a><a class="code" href="classOgre_1_1EdgeListBuilder.html#Ogre_1_1EdgeListBuilderp5">00247</a>         EdgeMap mEdgeMap;
00248 
00249         <span class="keywordtype">void</span> buildTrianglesEdges(<span class="keyword">const</span> <a class="code" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html">Geometry</a> &amp;geometry);
00250 
00252         size_t findOrCreateCommonVertex(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; vec, size_t vertexSet, 
00253             size_t indexSet, size_t originalIndex);
00255         <span class="keywordtype">void</span> connectOrCreateEdge(size_t vertexSet, size_t triangleIndex, size_t vertIndex0, size_t vertIndex1, 
00256             size_t sharedVertIndex0, size_t sharedVertIndex1);
00257     };
00258 
00259 }
00260 <span class="preprocessor">#endif</span>
00261 <span class="preprocessor"></span>
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Sep 30 10:50:56 2007
</p>
</body>
</html>
