<html>
<head>
<title>OGRE: OgreCompiler2Pass.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>OgreCompiler2Pass.h</h1><a href="OgreCompiler2Pass_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">(Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.ogre3d.org</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2006 Torus Knot Software Ltd</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU Lesser General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU Lesser General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/lesser.txt.</span>
00023 <span class="comment"></span>
00024 <span class="comment">You may alternatively use this source under the terms of a specific version of</span>
00025 <span class="comment">the OGRE Unrestricted License provided you have obtained such a license from</span>
00026 <span class="comment">Torus Knot Software Ltd.</span>
00027 <span class="comment">-----------------------------------------------------------------------------</span>
00028 <span class="comment">*/</span>
00029 
00030 
00031 <span class="preprocessor">#ifndef __Compiler2Pass_H__</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define __Compiler2Pass_H__</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#include "<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="OgreStdHeaders_8h.html">OgreStdHeaders.h</a>"</span>
00036 
00037 <span class="keyword">namespace </span>Ogre {
00038 
<a name="l00152"></a><a class="code" href="classOgre_1_1Compiler2Pass.html">00152</a>     <span class="keyword">class </span><a class="code" href="OgrePlatform_8h.html#a16">_OgreExport</a> Compiler2Pass
00153     {
00154 
00155     <span class="keyword">protected</span>:
00156 
00157         <span class="comment">// BNF operation types</span>
<a name="l00158"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx194">00158</a>         <span class="keyword">enum</span> OperationType {otUNKNOWN, otRULE, otAND, otOR, otOPTIONAL,
00159                             otREPEAT, otDATA, otNOT_TEST, otINSERT_TOKEN, otEND};
00160 
<a name="l00164"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">00164</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">TokenRule</a>
00165         {
<a name="l00166"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRuleo0">00166</a>             OperationType operation;
<a name="l00167"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRuleo1">00167</a>             size_t tokenID;
00168 
<a name="l00169"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRulea0">00169</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">TokenRule</a>(<span class="keywordtype">void</span>) : operation(otUNKNOWN), tokenID(0) {}
<a name="l00170"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRulea1">00170</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">TokenRule</a>(<span class="keyword">const</span> OperationType ot, <span class="keyword">const</span> size_t token)
00171                 : operation(ot), tokenID(token) {}
00172         };
00173 
<a name="l00174"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx119">00174</a>         <span class="keyword">typedef</span> std::vector&lt;TokenRule&gt; TokenRuleContainer;
<a name="l00175"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx120">00175</a>         <span class="keyword">typedef</span> TokenRuleContainer::iterator TokenRuleIterator;
00176 
<a name="l00177"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilert1">00177</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t SystemTokenBase = 1000;
<a name="l00178"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx195">00178</a>         <span class="keyword">enum</span> SystemRuleToken {
00179             _no_token_ = SystemTokenBase,
00180             _character_,
00181             _value_,
00182             _no_space_skip_
00183         };
00184 
<a name="l00185"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx196">00185</a>         <span class="keyword">enum</span> BNF_ID {BNF_UNKOWN = 0,
00186             BNF_SYNTAX, BNF_RULE, BNF_IDENTIFIER, BNF_IDENTIFIER_RIGHT, BNF_IDENTIFIER_CHARACTERS, BNF_ID_BEGIN, BNF_ID_END,
00187             BNF_CONSTANT_BEGIN, BNF_SET_RULE, BNF_EXPRESSION,
00188             BNF_AND_TERM, BNF_OR_TERM, BNF_TERM, BNF_TERM_ID, BNF_CONSTANT, BNF_OR, BNF_TERMINAL_SYMBOL, BNF_TERMINAL_START,
00189             BNF_REPEAT_EXPRESSION, BNF_REPEAT_BEGIN, BNF_REPEAT_END, BNF_SET, BNF_SET_BEGIN, BNF_SET_END,
00190             BNF_NOT_TEST, BNF_NOT_TEST_BEGIN, BNF_CONDITIONAL_TOKEN_INSERT, BNF_OPTIONAL_EXPRESSION,
00191             BNF_NOT_EXPRESSION, BNF_NOT_CHK,
00192             BNF_OPTIONAL_BEGIN, BNF_OPTIONAL_END, BNF_NO_TOKEN_START, BNF_SINGLEQUOTE, BNF_SINGLE_QUOTE_EXC, BNF_SET_END_EXC,
00193             BNF_ANY_CHARACTER, BNF_SPECIAL_CHARACTERS1,
00194             BNF_SPECIAL_CHARACTERS2, BNF_WHITE_SPACE_CHK,
00195 
00196             BNF_LETTER, BNF_LETTER_DIGIT, BNF_DIGIT, BNF_WHITE_SPACE,
00197             BNF_ALPHA_SET, BNF_NUMBER_SET, BNF_SPECIAL_CHARACTER_SET1,
00198             BNF_SPECIAL_CHARACTER_SET2, BNF_SPECIAL_CHARACTER_SET3, BNF_NOT_CHARS,
00199 
00200             <span class="comment">// do not remove - this indicates where manually defined tokens end and where auto-gen ones start</span>
00201             BNF_AUTOTOKENSTART
00202         };
00203 
00204 
<a name="l00206"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">00206</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">LexemeTokenDef</a>
00207         {
<a name="l00208"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo0">00208</a>             size_t ID;                  
<a name="l00209"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo1">00209</a>             <span class="keywordtype">bool</span> hasAction;            
<a name="l00210"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo2">00210</a>             <span class="keywordtype">bool</span> isNonTerminal;        
<a name="l00211"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo3">00211</a>             size_t ruleID;              
<a name="l00212"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo4">00212</a>             <span class="keywordtype">bool</span> isCaseSensitive;        
<a name="l00213"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo5">00213</a>             <a class="code" href="namespaceOgre.html#a357">String</a> lexeme;             
00214 
<a name="l00215"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefa0">00215</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">LexemeTokenDef</a>(<span class="keywordtype">void</span>) : ID(0), hasAction(false), isNonTerminal(false), ruleID(0), isCaseSensitive(false) {}
<a name="l00216"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefa1">00216</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">LexemeTokenDef</a>( <span class="keyword">const</span> size_t ID, <span class="keyword">const</span> String&amp; lexeme, <span class="keyword">const</span> <span class="keywordtype">bool</span> hasAction = <span class="keyword">false</span>, <span class="keyword">const</span> <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span> )
00217                 : ID(ID)
00218                 , hasAction(hasAction)
00219                 , isNonTerminal(false)
00220                 , ruleID(0)
00221                 , isCaseSensitive(caseSensitive)
00222                 , lexeme(lexeme)
00223             {
00224             }
00225 
00226         };
00227 
<a name="l00228"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx121">00228</a>         <span class="keyword">typedef</span> std::vector&lt;LexemeTokenDef&gt; LexemeTokenDefContainer;
<a name="l00229"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx122">00229</a>         <span class="keyword">typedef</span> LexemeTokenDefContainer::iterator LexemeTokenDefIterator;
00230 
<a name="l00231"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx123">00231</a>         <span class="keyword">typedef</span> std::map&lt;std::string, size_t&gt; LexemeTokenMap;
<a name="l00232"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx124">00232</a>         <span class="keyword">typedef</span> LexemeTokenMap::iterator TokenKeyIterator;
00234 
00235 
<a name="l00237"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html">00237</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html">TokenInst</a>
00238         {
<a name="l00239"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto0">00239</a>         size_t NTTRuleID;           
<a name="l00240"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto1">00240</a>         size_t tokenID;                 
<a name="l00241"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto2">00241</a>         size_t line;                
<a name="l00242"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto3">00242</a>         size_t pos;             
<a name="l00243"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto4">00243</a>         <span class="keywordtype">bool</span> found;                
00244         };
00245 
<a name="l00246"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx125">00246</a>         <span class="keyword">typedef</span> std::vector&lt;TokenInst&gt; TokenInstContainer;
<a name="l00247"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx126">00247</a>         <span class="keyword">typedef</span> TokenInstContainer::iterator TokenInstIterator;
00248 
00249         <span class="comment">// token que, definitions, rules</span>
<a name="l00250"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">00250</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a>
00251         {
<a name="l00252"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo0">00252</a>             TokenInstContainer       tokenQue;
<a name="l00253"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo1">00253</a>             LexemeTokenDefContainer  lexemeTokenDefinitions;
<a name="l00254"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo2">00254</a>             TokenRuleContainer       rootRulePath;
<a name="l00255"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo3">00255</a>             LexemeTokenMap           lexemeTokenMap;
00256         };
00257 
<a name="l00258"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp1">00258</a>         <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a>* mClientTokenState;
00259 
<a name="l00261"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp2">00261</a>         <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a>* mActiveTokenState;
<a name="l00263"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp3">00263</a>         <span class="keyword">mutable</span> size_t mPass2TokenQuePosition;
<a name="l00267"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp4">00267</a>         size_t mPreviousActionQuePosition;
<a name="l00270"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp5">00270</a>         size_t mNextActionQuePosition;
00271 
<a name="l00273"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp6">00273</a>         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>* mSource;
<a name="l00275"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp7">00275</a>         <a class="code" href="namespaceOgre.html#a357">String</a> mSourceName;
<a name="l00276"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp8">00276</a>         size_t mEndOfSource;
00277 
<a name="l00278"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp9">00278</a>         size_t mCurrentLine; 
<a name="l00279"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp10">00279</a>         size_t mCharPos;     
<a name="l00280"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp11">00280</a>         size_t mErrorCharPos; 
00281 
<a name="l00284"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp12">00284</a>         std::map&lt;size_t, float&gt; mConstants;
<a name="l00287"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx127">00287</a>         <span class="keyword">typedef</span> std::map&lt;size_t, String&gt; LabelContainer;
<a name="l00288"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp13">00288</a>         LabelContainer mLabels;
<a name="l00291"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp14">00291</a>         <span class="keywordtype">bool</span> mLabelIsActive;
<a name="l00294"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp15">00294</a>         size_t mActiveLabelKey;
<a name="l00296"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp16">00296</a>         <a class="code" href="namespaceOgre.html#a357">String</a>* mActiveLabel;
<a name="l00299"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp17">00299</a>         <span class="keywordtype">bool</span> mNoSpaceSkip;
<a name="l00302"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp18">00302</a>         <span class="keywordtype">bool</span> mNoTerminalToken;
<a name="l00305"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp19">00305</a>         size_t mInsertTokenID;
00306 
<a name="l00308"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp20">00308</a>         <a class="code" href="namespaceOgre.html#a354">uint</a> mActiveContexts;
00309 
00318         <span class="keywordtype">bool</span> doPass1();
00319 
00329         <span class="keywordtype">bool</span> doPass2();
00330 
00337         <span class="keyword">virtual</span> <span class="keywordtype">void</span> executeTokenAction(<span class="keyword">const</span> size_t tokenID) = 0;
00344         <span class="keyword">virtual</span> size_t getAutoTokenIDStart() <span class="keyword">const </span>= 0;
00347         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setupTokenDefinitions(<span class="keywordtype">void</span>) = 0;
<a name="l00356"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb99">00356</a>         <span class="keyword">const</span> <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html">TokenInst</a>&amp; getNextToken(<span class="keyword">const</span> size_t expectedTokenID = 0)<span class="keyword"> const</span>
00357 <span class="keyword">        </span>{
00358             skipToken();
00359             <span class="keywordflow">return</span> getCurrentToken(expectedTokenID);
00360         }
00369         <span class="keyword">const</span> TokenInst&amp; getCurrentToken(<span class="keyword">const</span> size_t expectedTokenID = 0) <span class="keyword">const</span>;
00377         <span class="keywordtype">bool</span> testNextTokenID(<span class="keyword">const</span> size_t expectedTokenID) <span class="keyword">const</span>;
00378 
<a name="l00382"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb102">00382</a>         <span class="keywordtype">bool</span> testCurrentTokenID(<span class="keyword">const</span> size_t expectedTokenID)<span class="keyword"> const</span>
00383 <span class="keyword">        </span>{
00384             <span class="keywordflow">return</span> mActiveTokenState-&gt;tokenQue[mPass2TokenQuePosition].tokenID == expectedTokenID;
00385         }
00388         <span class="keywordtype">void</span> skipToken(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00391         <span class="keywordtype">void</span> replaceToken(<span class="keywordtype">void</span>);
<a name="l00397"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb105">00397</a>         <span class="keywordtype">float</span> getNextTokenValue(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00398 <span class="keyword">        </span>{
00399             skipToken();
00400             <span class="keywordflow">return</span> getCurrentTokenValue();
00401         }
00408         <span class="keywordtype">float</span> getCurrentTokenValue(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00416"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb107">00416</a>         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>&amp; getNextTokenLabel(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00417 <span class="keyword">        </span>{
00418             skipToken();
00419             <span class="keywordflow">return</span> getCurrentTokenLabel();
00420         }
00425         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>&amp; getCurrentTokenLabel(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00428"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb109">00428</a>         size_t getNextTokenID(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> getNextToken().tokenID; }
<a name="l00431"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb110">00431</a>         size_t getCurrentTokenID(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> getCurrentToken().tokenID; }
<a name="l00435"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb111">00435</a>         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>&amp; getNextTokenLexeme(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00436 <span class="keyword">        </span>{
00437             skipToken();
00438             <span class="keywordflow">return</span> getCurrentTokenLexeme();
00439         }
00443         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>&amp; getCurrentTokenLexeme(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00446         size_t getPass2TokenQueCount(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00451         size_t getRemainingTokensForAction(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00462         <span class="keywordtype">void</span> setPass2TokenQuePosition(size_t pos, <span class="keyword">const</span> <span class="keywordtype">bool</span> activateAction = <span class="keyword">false</span>);
<a name="l00465"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb116">00465</a>         size_t getPass2TokenQuePosition(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mPass2TokenQuePosition; }
00475         <span class="keywordtype">bool</span> setNextActionQuePosition(size_t pos, <span class="keyword">const</span> <span class="keywordtype">bool</span> search = <span class="keyword">false</span>);
00487         size_t addLexemeToken(<span class="keyword">const</span> String&amp; lexeme, <span class="keyword">const</span> size_t token, <span class="keyword">const</span> <span class="keywordtype">bool</span> hasAction = <span class="keyword">false</span>, <span class="keyword">const</span> <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>);
00488 
00499         <span class="keywordtype">void</span> setClientBNFGrammer(<span class="keywordtype">void</span>);
00500 
00501 
00502 
00504         <span class="keywordtype">void</span> findEOL();
00505 
00513         <span class="keywordtype">bool</span> isFloatValue(<span class="keywordtype">float</span>&amp; fvalue, size_t&amp; charsize) <span class="keyword">const</span>;
00514 
00523         <span class="keywordtype">bool</span> isCharacterLabel(<span class="keyword">const</span> size_t rulepathIDX);
00531         <span class="keywordtype">bool</span> isLexemeMatch(<span class="keyword">const</span> String&amp; lexeme, <span class="keyword">const</span> <span class="keywordtype">bool</span> caseSensitive) <span class="keyword">const</span>;
<a name="l00533"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb124">00533</a>         <span class="keywordtype">bool</span> isEndOfSource()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mCharPos &gt;= mEndOfSource; }
00535         <span class="keywordtype">bool</span> positionToNextLexeme();
00556         <span class="keywordtype">bool</span> processRulePath( size_t rulepathIDX);
00557 
00558 
<a name="l00561"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb127">00561</a>         <span class="keywordtype">void</span> setActiveContexts(<span class="keyword">const</span> uint contexts){ mActiveContexts = contexts; }
00562 
00564         <span class="keywordtype">void</span> skipComments();
00565 
00567         <span class="keywordtype">void</span> skipEOL();
00568 
00570         <span class="keywordtype">void</span> skipWhiteSpace();
00571 
00572 
00581         <span class="keywordtype">bool</span> ValidateToken(<span class="keyword">const</span> size_t rulepathIDX, <span class="keyword">const</span> size_t activeRuleID);
00582 
00587         <span class="keywordtype">void</span> verifyTokenRuleLinks(<span class="keyword">const</span> String&amp; grammerName);
00591         <span class="keywordtype">void</span> checkTokenActionTrigger(<span class="keywordtype">void</span>);
00598         <a class="code" href="namespaceOgre.html#a357">String</a> getBNFGrammerTextFromRulePath(size_t ruleID, <span class="keyword">const</span> size_t level = 0);
00599 
00600 
00601     <span class="keyword">private</span>:
00602         <span class="comment">// used for interpreting BNF script</span>
00603         <span class="comment">// keep it as static so that only one structure is created</span>
00604         <span class="comment">// no matter how many times this class is instantiated.</span>
<a name="l00605"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passv0">00605</a>         <span class="keyword">static</span> <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a> mBNFTokenState;
00606         <span class="comment">// maintain a map of BNF grammer</span>
<a name="l00607"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passy0">00607</a>         <span class="keyword">typedef</span> std::map&lt;String, TokenState&gt; TokenStateContainer;
<a name="l00608"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passv1">00608</a>         <span class="keyword">static</span> TokenStateContainer mClientTokenStates;
00610         <span class="keywordtype">void</span> activatePreviousTokenAction(<span class="keywordtype">void</span>);
00612         <span class="keywordtype">void</span> initBNFCompiler(<span class="keywordtype">void</span>);
00614         <span class="keywordtype">void</span> buildClientBNFRulePaths(<span class="keywordtype">void</span>);
00616         <span class="keywordtype">void</span> modifyLastRule(<span class="keyword">const</span> OperationType pendingRuleOp, <span class="keyword">const</span> size_t tokenID);
00621         size_t getClientLexemeTokenID(<span class="keyword">const</span> String&amp; lexeme, <span class="keyword">const</span> <span class="keywordtype">bool</span> isCaseSensitive = <span class="keyword">false</span>);
00623         <span class="keywordtype">void</span> extractNonTerminal(<span class="keyword">const</span> OperationType pendingRuleOp);
00625         <span class="keywordtype">void</span> extractTerminal(<span class="keyword">const</span> OperationType pendingRuleOp, <span class="keyword">const</span> <span class="keywordtype">bool</span> notoken = <span class="keyword">false</span>);
00627         <span class="keywordtype">void</span> extractSet(<span class="keyword">const</span> OperationType pendingRuleOp);
00629         <span class="keywordtype">void</span> extractNumericConstant(<span class="keyword">const</span> OperationType pendingRuleOp);
00631         <span class="keywordtype">void</span> setConditionalTokenInsert(<span class="keywordtype">void</span>);
00633         <a class="code" href="namespaceOgre.html#a357">String</a> getLexemeText(size_t&amp; ruleID, <span class="keyword">const</span> size_t level = 0);
00634 
00635 
00636     <span class="keyword">public</span>:
00637 
00639         Compiler2Pass();
<a name="l00640"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passa1">00640</a>         <span class="keyword">virtual</span> ~Compiler2Pass() {}
00641 
00653         <span class="keywordtype">bool</span> compile(<span class="keyword">const</span> String&amp; source, <span class="keyword">const</span> String&amp; sourceName);
00656         <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>&amp; getClientBNFGrammer(<span class="keywordtype">void</span>) <span class="keyword">const </span>= 0;
00657 
00660         <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a357">String</a>&amp; getClientGrammerName(<span class="keywordtype">void</span>) <span class="keyword">const </span>= 0;
00661 
00662     };
00663 
00664 }
00665 
00666 <span class="preprocessor">#endif</span>
00667 <span class="preprocessor"></span>
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Sep 30 10:50:56 2007
</p>
</body>
</html>
