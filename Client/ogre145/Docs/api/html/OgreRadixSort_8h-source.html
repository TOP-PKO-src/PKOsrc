<html>
<head>
<title>OGRE: OgreRadixSort.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>OgreRadixSort.h</h1><a href="OgreRadixSort_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">    (Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.ogre3d.org/</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2006 Torus Knot Software Ltd</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU Lesser General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU Lesser General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/lesser.txt.</span>
00023 <span class="comment"></span>
00024 <span class="comment">You may alternatively use this source under the terms of a specific version of</span>
00025 <span class="comment">the OGRE Unrestricted License provided you have obtained such a license from</span>
00026 <span class="comment">Torus Knot Software Ltd.</span>
00027 <span class="comment">-----------------------------------------------------------------------------</span>
00028 <span class="comment">*/</span>
00029 <span class="preprocessor">#ifndef __RadixSort_H__</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define __RadixSort_H__</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#include "<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>"</span>
00033 
00034 <span class="keyword">namespace </span>Ogre {
00035 
00082     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TContainer, <span class="keyword">class</span> TContainerValueType, <span class="keyword">typename</span> TCompValueType&gt;
<a name="l00083"></a><a class="code" href="classOgre_1_1RadixSort.html">00083</a>     <span class="keyword">class </span><a class="code" href="classOgre_1_1RadixSort.html">RadixSort</a>
00084     {
00085     <span class="keyword">public</span>:
<a name="l00086"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortw0">00086</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> TContainer::iterator ContainerIter;
00087     <span class="keyword">protected</span>:
<a name="l00090"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">00090</a>         <span class="keywordtype">int</span> mCounters[4][256];
<a name="l00092"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">00092</a>         <span class="keywordtype">int</span> mOffsets[256];
<a name="l00094"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">00094</a>         <span class="keywordtype">int</span> mSortSize;
<a name="l00096"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">00096</a>         <span class="keywordtype">int</span> mNumPasses;
00097 
<a name="l00098"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html">00098</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html">SortEntry</a>
00099         {
<a name="l00100"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo0">00100</a>             TCompValueType <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo0">key</a>;
<a name="l00101"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo1">00101</a>             ContainerIter <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo1">iter</a>;
<a name="l00102"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya0">00102</a>             <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya0">SortEntry</a>() {}
<a name="l00103"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya1">00103</a>             <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya0">SortEntry</a>(TCompValueType k, ContainerIter it)
00104                 : <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo0">key</a>(k), <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo1">iter</a>(it) {}
00105 
00106         };
<a name="l00108"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">00108</a>         std::vector&lt;SortEntry&gt; mSortArea1;
<a name="l00109"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp5">00109</a>         std::vector&lt;SortEntry&gt; mSortArea2;
<a name="l00110"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">00110</a>         std::vector&lt;SortEntry&gt;* mSrc;
<a name="l00111"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp7">00111</a>         std::vector&lt;SortEntry&gt;* mDest;
<a name="l00112"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp8">00112</a>         TContainer mTmpContainer; <span class="comment">// initial copy</span>
00113 
00114 
<a name="l00115"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">00115</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">sortPass</a>(<span class="keywordtype">int</span> byteIndex)
00116         {
00117             <span class="comment">// Calculate offsets</span>
00118             <span class="comment">// Basically this just leaves gaps for duplicate entries to fill</span>
00119             mOffsets[0] = 0;
00120             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 256; ++i)
00121             {
00122                 mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
00123             }
00124 
00125             <span class="comment">// Sort pass</span>
00126             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mSortSize; ++i)
00127             {
00128                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(byteIndex, (*mSrc)[i].key);
00129                 (*mDest)[mOffsets[byteVal]++] = (*mSrc)[i];
00130             }
00131 
00132         }
00133         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00134"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">00134</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(<span class="keywordtype">int</span> byteIndex, T val)
00135         {
00136             <span class="comment">// default is to do normal pass</span>
00137             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">sortPass</a>(byteIndex);
00138         }
00139         
00140         <span class="comment">// special case signed int</span>
<a name="l00141"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb2">00141</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(<span class="keywordtype">int</span> byteIndex, <span class="keywordtype">int</span> val)
00142         {
00143             <span class="keywordtype">int</span> numNeg = 0;
00144             <span class="comment">// all negative values are in entries 128+ in most significant byte</span>
00145             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 128; i &lt; 256; ++i)
00146             {
00147                 numNeg += mCounters[byteIndex][i];
00148             }
00149             <span class="comment">// Calculate offsets - positive ones start at the number of negatives</span>
00150             <span class="comment">// do positive numbers</span>
00151             mOffsets[0] = numNeg;
00152             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 128; ++i)
00153             {
00154                 mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
00155             }
00156             <span class="comment">// Do negative numbers (must start at zero)</span>
00157             <span class="comment">// No need to invert ordering, already correct (-1 is highest number)</span>
00158             mOffsets[128] = 0;
00159             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 129; i &lt; 256; ++i)
00160             {
00161                 mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
00162             }
00163 
00164             <span class="comment">// Sort pass</span>
00165             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mSortSize; ++i)
00166             {
00167                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(byteIndex, (*mSrc)[i].key);
00168                 (*mDest)[mOffsets[byteVal]++] = (*mSrc)[i];
00169             }
00170         }
00171         
00172 
00173         <span class="comment">// special case float</span>
<a name="l00174"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb3">00174</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(<span class="keywordtype">int</span> byteIndex, <span class="keywordtype">float</span> val)
00175         {
00176             <span class="comment">// floats need to be special cased since negative numbers will come</span>
00177             <span class="comment">// after positives (high bit = sign) and will be in reverse order</span>
00178             <span class="comment">// (no ones-complement of the +ve value)</span>
00179             <span class="keywordtype">int</span> numNeg = 0;
00180             <span class="comment">// all negative values are in entries 128+ in most significant byte</span>
00181             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 128; i &lt; 256; ++i)
00182             {
00183                 numNeg += mCounters[byteIndex][i];
00184             }
00185             <span class="comment">// Calculate offsets - positive ones start at the number of negatives</span>
00186             <span class="comment">// do positive numbers normally</span>
00187             mOffsets[0] = numNeg;
00188             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 128; ++i)
00189             {
00190                 mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
00191             }
00192             <span class="comment">// Do negative numbers (must start at zero)</span>
00193             <span class="comment">// Also need to invert ordering</span>
00194             <span class="comment">// In order to preserve the stability of the sort (essential since</span>
00195             <span class="comment">// we rely on previous bytes already being sorted) we have to count</span>
00196             <span class="comment">// backwards in our offsets from </span>
00197             mOffsets[255] = mCounters[byteIndex][255];
00198             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 254; i &gt; 127; --i)
00199             {
00200                 mOffsets[i] = mOffsets[i+1] + mCounters[byteIndex][i];
00201             }
00202 
00203             <span class="comment">// Sort pass</span>
00204             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mSortSize; ++i)
00205             {
00206                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(byteIndex, (*mSrc)[i].key);
00207                 <span class="keywordflow">if</span> (byteVal &gt; 127)
00208                 {
00209                     <span class="comment">// -ve; pre-decrement since offsets set to count</span>
00210                     (*mDest)[--mOffsets[byteVal]] = (*mSrc)[i];
00211                 }
00212                 <span class="keywordflow">else</span>
00213                 {
00214                     <span class="comment">// +ve</span>
00215                     (*mDest)[mOffsets[byteVal]++] = (*mSrc)[i];
00216                 }
00217             }
00218         }
00219 
<a name="l00220"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">00220</a>         <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(<span class="keywordtype">int</span> byteIndex, TCompValueType val)
00221         {
00222 <span class="preprocessor">#if OGRE_ENDIAN == OGRE_ENDIAN_LITTLE</span>
00223 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)(&amp;val))[byteIndex];
00224 <span class="preprocessor">#else</span>
00225 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)(&amp;val))[mNumPasses - byteIndex - 1];
00226 <span class="preprocessor">#endif</span>
00227 <span class="preprocessor"></span>        }
00228 
00229     <span class="keyword">public</span>:
00230 
<a name="l00231"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta0">00231</a>         <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta0">RadixSort</a>() {}
<a name="l00232"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta1">00232</a>         <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta1">~RadixSort</a>() {}
00233 
00239         <span class="keyword">template</span> &lt;<span class="keyword">class</span> TFunction&gt;
<a name="l00240"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta2">00240</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta2">sort</a>(TContainer&amp; container, TFunction func)
00241         {
00242             <span class="keywordflow">if</span> (container.empty())
00243                 <span class="keywordflow">return</span>;
00244 
00245             <span class="comment">// Set up the sort areas</span>
00246             mSortSize = static_cast&lt;int&gt;(container.size());
00247             mSortArea1.resize(container.size());
00248             mSortArea2.resize(container.size());
00249 
00250             <span class="comment">// Copy data now (we need constant iterators for sorting)</span>
00251             mTmpContainer = container;
00252 
00253             mNumPasses = <span class="keyword">sizeof</span>(TCompValueType);
00254 
00255             <span class="comment">// Counter pass</span>
00256             <span class="comment">// Initialise the counts</span>
00257             <span class="keywordtype">int</span> p;
00258             <span class="keywordflow">for</span> (p = 0; p &lt; mNumPasses; ++p)
00259                 memset(mCounters[p], 0, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * 256);
00260 
00261             <span class="comment">// Perform alpha pass to count</span>
00262             ContainerIter i = mTmpContainer.begin();
00263             TCompValueType prevValue = func.operator()(*i); 
00264             <span class="keywordtype">bool</span> needsSorting = <span class="keyword">false</span>;
00265             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; i != mTmpContainer.end(); ++i, ++u)
00266             {
00267                 <span class="comment">// get sort value</span>
00268                 TCompValueType val = func.operator()(*i);
00269                 <span class="comment">// cheap check to see if needs sorting (temporal coherence)</span>
00270                 <span class="keywordflow">if</span> (!needsSorting &amp;&amp; val &lt; prevValue)
00271                     needsSorting = <span class="keyword">true</span>;
00272 
00273                 <span class="comment">// Create a sort entry</span>
00274                 mSortArea1[u].key = val;
00275                 mSortArea1[u].iter = i;
00276 
00277                 <span class="comment">// increase counters</span>
00278                 <span class="keywordflow">for</span> (p = 0; p &lt; mNumPasses; ++p)
00279                 {
00280                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(p, val);
00281                     mCounters[p][byteVal]++;
00282                 }
00283 
00284                 prevValue = val;
00285 
00286             }
00287 
00288             <span class="comment">// early exit if already sorted</span>
00289             <span class="keywordflow">if</span> (!needsSorting)
00290                 <span class="keywordflow">return</span>;
00291 
00292 
00293             <span class="comment">// Sort passes</span>
00294             mSrc = &amp;mSortArea1;
00295             mDest = &amp;mSortArea2;
00296 
00297             <span class="keywordflow">for</span> (p = 0; p &lt; mNumPasses - 1; ++p)
00298             {
00299                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">sortPass</a>(p);
00300                 <span class="comment">// flip src/dst</span>
00301                 std::vector&lt;SortEntry&gt;* tmp = mSrc;
00302                 mSrc = mDest;
00303                 mDest = tmp;
00304             }
00305             <span class="comment">// Final pass may differ, make polymorphic</span>
00306             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(p, prevValue);
00307 
00308             <span class="comment">// Copy everything back</span>
00309             <span class="keywordtype">int</span> c = 0;
00310             <span class="keywordflow">for</span> (i = container.begin(); 
00311                 i != container.end(); ++i, ++c)
00312             {
00313                 *i = *((*mDest)[c].iter);
00314             }
00315         }
00316 
00317     };
00318 
00319 
00320 }
00321 <span class="preprocessor">#endif</span>
00322 <span class="preprocessor"></span>
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Sep 30 10:50:57 2007
</p>
</body>
</html>
